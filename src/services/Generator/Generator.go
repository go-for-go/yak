package Generator

import (
	"errors"
	"fmt"
	"github.com/dave/jennifer/jen"
	"github.com/pelletier/go-toml"
	"path/filepath"
	"regexp"
	"sort"
	"strings"
)

const (
	viperPath     = "github.com/spf13/viper"
	moduleField   = "module"
	moduleConst   = "MODULE"
	pgFunc        = "GetConnection"
	pgDsn         = "PgDsn"
	mqFunc        = "Url"
	defaultMqPort = 5672
	defaultPgPort = 5432
)

func pgCheckArray() []string {
	return []string{"database", "user", "host", "pass"}
}

func mqCheckArray() []string {
	return []string{"user", "pass", "host"}
}

func depsCheckArray() []string {
	return []string{"url"}
}

type Gen struct {
	hasPg bool
	Pg10  bool
}

func checkModuleField(config *toml.Tree, gr *jen.Group) error {
	if !contains(config.Keys(), moduleField) {
		return errors.New("config должен иметь поле " + moduleField + " верхнего уровня")
	}
	moduleVal := fmt.Sprintf("%s", config.Get(moduleField))
	if moduleVal == "" {
		return errors.New(moduleField + " не может быть пустым")
	}
	moduleVal = strings.ToUpper(strings.ReplaceAll(moduleVal, "-", "_"))

	gr.Const().Defs(jen.Id(moduleConst).Op("=").Lit(moduleVal)).Line()

	return nil
}

func (g *Gen) Run(input, output string) error {
	if filepath.Ext(input) != ".toml" {
		return errors.New("config file must be .toml extension")
	}

	config, err := toml.LoadFile(input)
	if err != nil {
		return err
	}

	f := jen.NewFile("conf")
	gr := &jen.Group{}
	valid := &jen.Group{}

	err = checkModuleField(config, gr)
	if err != nil {
		return err
	}

	err = g.parseTree(config, []string{}, gr, valid)
	if err != nil {
		return err
	}

	g.generateBase(f)
	f.Add(gr)

	f.Func().Id("Validate").Params().Error().BlockFunc(func(g *jen.Group) {
		g.Add(valid)
		g.Return(jen.Nil())
	}).Line()

	//fmt.Printf("%#v", f)
	err = f.Save(output) //savePath
	if err != nil {
		fmt.Println(err)
		return err
	}

	return nil
}

type importsStructure struct {
	Name string
	Path string
}

func (g *Gen) generateBase(f *jen.File) {
	f.PackageComment("Code generated by github.com/dave/jennifer/jen. DO NOT EDIT.")
}

func (g *Gen) parseTree(tree *toml.Tree, path []string, f, valid *jen.Group) (err error) {
	keys := tree.Keys()
	sort.Strings(keys)

	for _, l := range keys {

		name := renameToCamel(strings.Join(path, "") + l + "Node")
		pathLocal := append(path, l)
		inner := tree.Get(l)
		structName := renameToCamel(strings.Join(path, "")) + "Node"
		funcName := strings.Title(renameToCamel(l))

		if innerTree, ok := inner.(*toml.Tree); ok {
			err = g.implementPgConnection(path, pathLocal, innerTree, f)
			if err != nil {
				return
			}
			err = g.implementMqConnection(path, pathLocal, innerTree, f)
			if err != nil {
				return
			}
			err = g.implementDeps(path, pathLocal, innerTree)
			if err != nil {
				return
			}
			g.implementFtp(path, pathLocal, innerTree, f)

			f.Type().Id(name).StructFunc(func(g *jen.Group) {
				getChild(innerTree, pathLocal, g)
			}).Line()

			if len(path) == 0 {
				structName = renameToCamel(l + "Node")
				f.Func().Id(funcName).Params().Id(structName).BlockFunc(func(g *jen.Group) {
					g.Return(jen.Id(structName).Values())
				}).Line()
			} else {
				retType := renameToCamel(strings.Join(pathLocal, "") + "Node")
				f.Func().Params(jen.Id("s").Id(structName)).Id(funcName).Params().Id(retType).BlockFunc(func(g *jen.Group) {
					g.Return(jen.Id(retType).Values())
				}).Line()
			}
			err = g.parseTree(innerTree, pathLocal, f, valid)
			if err != nil {
				return
			}
		} else {
			if len(path) == 0 {
				switch elemType := inner.(type) {
				case int64, int32, int16, int8, int:
					f.Func().Id(funcName).Params().Int().BlockFunc(func(g *jen.Group) {
						g.Return(jen.Id("viper").Dot("GetInt").Call(jen.Lit(strings.Join(pathLocal, "."))))
					}).Line()
					f.Func().Id(funcName + "32").Params().Int32().BlockFunc(func(g *jen.Group) {
						g.Return(jen.Id("viper").Dot("GetInt32").Call(jen.Lit(strings.Join(pathLocal, "."))))
					}).Line()
					f.Func().Id(funcName + "64").Params().Int64().BlockFunc(func(g *jen.Group) {
						g.Return(jen.Id("viper").Dot("GetInt64").Call(jen.Lit(strings.Join(pathLocal, "."))))
					})
				case bool:
					f.Func().Id(funcName).Params().Bool().BlockFunc(func(g *jen.Group) {
						g.Return(jen.Qual(viperPath, "GetBool").Call(jen.Lit(strings.Join(pathLocal, "."))))
					})
				case []interface{}:
					switch elemType[0].(type) {
					case int64, int32, int16, int8, int:
						f.Func().Id(funcName).Params().Index().Int().BlockFunc(func(g *jen.Group) {
							g.Return(jen.Qual(viperPath, "GetIntSlice").Call(jen.Lit(strings.Join(pathLocal, "."))))
						})
					default:
						f.Func().Id(funcName).Params().Index().String().BlockFunc(func(g *jen.Group) {
							g.Return(jen.Qual(viperPath, "GetStringSlice").Call(jen.Lit(strings.Join(pathLocal, "."))))
						})
					}
				default:
					f.Func().Id(funcName).Params().String().BlockFunc(func(g *jen.Group) {
						g.Return(jen.Qual(viperPath, "GetString").Call(jen.Lit(strings.Join(pathLocal, "."))))
					})
				}
			} else if !checkFtpPort(pathLocal, structName, funcName, f) {
				switch elemType := inner.(type) {
				case int64, int32, int16, int8, int:
					f.Func().Params(jen.Id("s").Id(structName)).Id(funcName).Params().Int().BlockFunc(func(g *jen.Group) {
						g.Return(jen.Id("viper").Dot("GetInt").Call(jen.Lit(strings.Join(pathLocal, "."))))
					}).Line()
					f.Func().Params(jen.Id("s").Id(structName)).Id(funcName + "32").Params().Int32().BlockFunc(func(g *jen.Group) {
						g.Return(jen.Id("viper").Dot("GetInt32").Call(jen.Lit(strings.Join(pathLocal, "."))))
					}).Line()
					f.Func().Params(jen.Id("s").Id(structName)).Id(funcName + "64").Params().Int64().BlockFunc(func(g *jen.Group) {
						g.Return(jen.Id("viper").Dot("GetInt64").Call(jen.Lit(strings.Join(pathLocal, "."))))
					})
				case bool:
					f.Func().Params(jen.Id("s").Id(structName)).Id(funcName).Params().Bool().BlockFunc(func(g *jen.Group) {
						g.Return(jen.Qual(viperPath, "GetBool").Call(jen.Lit(strings.Join(pathLocal, "."))))
					})
				case []interface{}:
					switch elemType[0].(type) {
					case int64, int32, int16, int8, int:
						f.Func().Params(jen.Id("s").Id(structName)).Id(funcName).Params().Index().Int().BlockFunc(func(g *jen.Group) {
							g.Return(jen.Qual(viperPath, "GetIntSlice").Call(jen.Lit(strings.Join(pathLocal, "."))))
						})
					default:
						f.Func().Params(jen.Id("s").Id(structName)).Id(funcName).Params().Index().String().BlockFunc(func(g *jen.Group) {
							g.Return(jen.Qual(viperPath, "GetStringSlice").Call(jen.Lit(strings.Join(pathLocal, "."))))
						})
					}
				default:
					f.Func().Params(jen.Id("s").Id(structName)).Id(funcName).Params().String().BlockFunc(func(g *jen.Group) {
						g.Return(jen.Qual(viperPath, "GetString").Call(jen.Lit(strings.Join(pathLocal, "."))))
					})
				}
			}
			f.Line()

			checkExist(pathLocal, valid)
			checkModuleValid(pathLocal, valid)
			checkPgFields(pathLocal, valid)
			checkMqFields(pathLocal, valid)
		}
	}
	return
}

func checkKeys(keysIn, keysCheck []string, path string) error {
	for _, e := range keysCheck {
		if !contains(keysIn, e) {
			return errors.New(path + " config not contains " + e)
		}
	}
	return nil
}

func contains(keys []string, e string) bool {
	for _, el := range keys {
		if el == e {
			return true
		}
	}
	return false
}

func getChild(tree *toml.Tree, path []string, g *jen.Group) {
	for _, l := range tree.Keys() {
		inner := tree.Get(l)
		if _, ok := inner.(*toml.Tree); ok {
			name := renameToCamel(strings.Join(path, "") + l + "Node")
			g.Add(jen.Id(name).Id(name))
		}
	}
}

func checkExist(pathLocal []string, valid *jen.Group) {
	valid.If(jen.Op("!").Qual(viperPath, "IsSet").Call(jen.Lit(strings.Join(pathLocal, ".")))).Block(
		jen.Return(jen.Qual("errors", "New").Call(jen.Lit(strings.Join(pathLocal, ".") + " not exist")))).Line()
}

func checkPgFields(pathLocal []string, valid *jen.Group) {
	re := regexp.MustCompile(`(?m)pg.(\w+).(\w+)`)
	if re.MatchString(strings.Join(pathLocal, ".")) {
		valid.If(jen.Qual(viperPath, "GetString").Call(jen.Lit(strings.Join(pathLocal, "."))).Op("==").Lit("")).Block(
			jen.Return(jen.Qual("errors", "New").Call(jen.Lit(strings.Join(pathLocal, ".") + " can't be empty")))).Line()
	}
}

func checkMqFields(pathLocal []string, valid *jen.Group) {
	regexOr := strings.Join(mqCheckArray(), "|")
	template := fmt.Sprintf(`(?m)mq.(\w+).(%s)`, regexOr)

	re := regexp.MustCompile(template)
	if re.MatchString(strings.Join(pathLocal, ".")) {
		valid.If(jen.Qual(viperPath, "GetString").Call(jen.Lit(strings.Join(pathLocal, "."))).Op("==").Lit("")).Block(
			jen.Return(jen.Qual("errors", "New").Call(jen.Lit(strings.Join(pathLocal, ".") + " can't be empty")))).Line()
	}
}

func checkModuleValid(pathLocal []string, valid *jen.Group) {
	if strings.Join(pathLocal, ".") == moduleField {
		valid.If(jen.Qual(viperPath, "GetString").Call(jen.Lit(strings.Join(pathLocal, "."))).Op("==").Lit("")).Block(
			jen.Return(jen.Qual("errors", "New").Call(jen.Lit(strings.Join(pathLocal, ".") + " can't be empty")))).Line()
	}
}

func (g *Gen) implementPgConnection(path, pathLocal []string, innerTree *toml.Tree, f *jen.Group) (err error) {
	joined := strings.Join(path, ".")
	if joined == "pg" {
		structPg := renameToCamel(strings.Join(pathLocal, "") + "Node")
		g.hasPg = true

		err = checkKeys(innerTree.Keys(), pgCheckArray(), strings.Join(pathLocal, "."))
		if err != nil {
			return
		}

		f.Func().Params(jen.Id("s").Id(structPg)).Id(pgDsn).Params().String().BlockFunc(func(g *jen.Group) {
			g.Id("user").Op(":=").Id("s").Dot("User").Call()
			g.Id("pass").Op(":=").Id("s").Dot("Pass").Call()
			g.Id("host").Op(":=").Id("s").Dot("Host").Call()
			g.Id("database").Op(":=").Id("s").Dot("Database").Call()

			g.Id("sslmode").Op(":=").Lit("disable")
			if contains(innerTree.Keys(), "sslmode") {
				g.If(jen.Id("s").Dot("Sslmode").Call()).Block(
					jen.Id("sslmode").Op("=").Lit("enable"))
			}
			g.Return(jen.Qual("fmt", "Sprintf").Call(jen.Lit("postgres://%s:%s@%s/%s?sslmode=%s"), jen.Id("user"),
				jen.Id("pass"), jen.Id("host"), jen.Id("database"), jen.Id("sslmode")))
		}).Line()
	}
	return
}

func (g *Gen) implementMqConnection(path, pathLocal []string, innerTree *toml.Tree, f *jen.Group) (err error) {
	joined := strings.Join(path, ".")
	if joined == "mq" {
		structMq := renameToCamel(strings.Join(pathLocal, "") + "Node")

		err = checkKeys(innerTree.Keys(), mqCheckArray(), strings.Join(pathLocal, "."))
		if err != nil {
			return
		}

		f.Func().Params(jen.Id("s").Id(structMq)).Id(mqFunc).Params().String().BlockFunc(func(g *jen.Group) {
			if contains(innerTree.Keys(), "port") {
				g.Id("port").Op(":=").Id("s").Dot("Port").Call()
				g.If(jen.Id("port").Op("==").Lit(0)).Block(
					jen.Id("port").Op("=").Lit(defaultMqPort))
			} else {
				g.Id("port").Op(":=").Lit(defaultMqPort)
			}
			if contains(innerTree.Keys(), "vhost") {
				g.Id("vhost").Op(":=").Lit("")
				g.If(jen.Id("s").Dot("Vhost").Call().Op("!=").Lit("")).Block(
					jen.Id("vhost").Op("=").Lit("/").Op("+").Id("s").Dot("Vhost").Call())
			} else {
				g.Id("vhost").Op(":=").Lit("")
			}
			g.Id("user").Op(":=").Id("s").Dot("User").Call()
			g.Id("pass").Op(":=").Id("s").Dot("Pass").Call()
			g.Id("host").Op(":=").Id("s").Dot("Host").Call()

			g.Return(jen.Qual("fmt", "Sprintf").Call(jen.Lit("amqp://%s:%s@%s:%d%s"), jen.Id("user"),
				jen.Id("pass"), jen.Id("host"), jen.Id("port"), jen.Id("vhost")))
		}).Line()
	}
	return
}

func (g *Gen) implementFtp(path, pathLocal []string, innerTree *toml.Tree, f *jen.Group) {
	joined := strings.Join(path, ".")
	if joined == "ftp" {
		structFtp := renameToCamel(strings.Join(pathLocal, "") + "Node")

		if !contains(innerTree.Keys(), "port") {
			f.Func().Params(jen.Id("s").Id(structFtp)).Id("Port").Params().Int().BlockFunc(func(g *jen.Group) {
				g.Return(jen.Lit(21))
			}).Line()
		}
	}
}

func checkFtpPort(pathLocal []string, structName, funcName string, f *jen.Group) bool {
	re := regexp.MustCompile(`(?m)ftp.(\w+).port`)
	if re.MatchString(strings.Join(pathLocal, ".")) {
		f.Func().Params(jen.Id("s").Id(structName)).Id(funcName).Params().Int().BlockFunc(func(g *jen.Group) {
			g.If(jen.Qual(viperPath, "GetInt").Call(jen.Lit(strings.Join(pathLocal, "."))).Op("==").Lit(0)).Block(jen.Return(jen.Lit(21)))
			g.Return(jen.Qual(viperPath, "GetInt").Call(jen.Lit(strings.Join(pathLocal, "."))))
		})
		return true
	}
	return false
}

func (g *Gen) implementDeps(path, pathLocal []string, innerTree *toml.Tree) (err error) {
	joined := strings.Join(path, ".")
	if joined == "deps" {
		err = checkKeys(innerTree.Keys(), depsCheckArray(), strings.Join(pathLocal, "."))
		if err != nil {
			return
		}
	}
	return
}

func renameToCamel(s string) string {
	var re = regexp.MustCompile(`(?m)[^A-z0-9\s][A-z]`)
	return re.ReplaceAllStringFunc(s, delDelimiter)
}

func delDelimiter(s string) string {
	var re = regexp.MustCompile(`(?m)[^A-z0-9\s]`)
	s = re.ReplaceAllString(s, "")
	return strings.ToUpper(s)
}
